"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestAfterHook = void 0;
// Function to check if the code is running in a Node.js environment
function isNodeEnvironment() {
    return (typeof process !== "undefined" && process.versions && process.versions.node);
}
// Compute HMAC SHA256
function computeHmacSha256(message, key) {
    return __awaiter(this, void 0, void 0, function* () {
        if (isNodeEnvironment()) {
            // Node.js environment
            const crypto = require("crypto");
            const hmac = crypto.createHmac("sha256", key);
            hmac.update(message);
            return hmac.digest("base64"); // or return Buffer if you want raw bytes
        }
        else {
            // Browser environment
            const encoder = new TextEncoder();
            const keyBuffer = encoder.encode(key);
            const msgBuffer = encoder.encode(message);
            const cryptoKey = yield globalThis.crypto.subtle.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
            const signature = yield globalThis.crypto.subtle.sign("HMAC", cryptoKey, msgBuffer);
            const byteArray = Array.from(new Uint8Array(signature));
            // Convert byte array to base64
            const base64 = btoa(String.fromCharCode.apply(null, byteArray));
            return base64;
        }
    });
}
const JSONstringifyOrder = (obj) => {
    var allKeys = [];
    var seen = {};
    JSON.stringify(obj, function (key, value) {
        if (!(key in seen)) {
            allKeys.push(key);
            seen[key] = null;
        }
        return value;
    });
    allKeys.sort();
    return JSON.stringify(obj, allKeys);
};
function requestAfterHook(request) {
    return __awaiter(this, void 0, void 0, function* () {
        const { configuration, basePath, axiosArgs, url } = request;
        if ((configuration === null || configuration === void 0 ? void 0 : configuration.consumerKey) === undefined)
            throw Error("Consumer key is required");
        const consumerKey = encodeURI(configuration.consumerKey);
        const requestData = axiosArgs.options.data === undefined || axiosArgs.options.data === "{}"
            ? null
            : JSON.parse(axiosArgs.options.data);
        const path = axiosArgs.url.indexOf("?") === -1
            ? `${axiosArgs.url}`
            : `${axiosArgs.url.split("?")[0]}`;
        const requestPath = `/api/v1${path}`;
        const requestQuery = url
            .replace(basePath, "")
            .replace(path, "")
            .replace("?", "");
        const sigObject = {
            content: requestData,
            path: requestPath,
            query: requestQuery,
        };
        const sigContent = JSONstringifyOrder(sigObject);
        const signature = yield computeHmacSha256(sigContent, consumerKey);
        if (axiosArgs.options.headers)
            axiosArgs.options.headers["Signature"] = signature;
    });
}
exports.requestAfterHook = requestAfterHook;
