"use strict";
/* tslint:disable */
/* eslint-disable */
/*
SnapTrade

Connect brokerage accounts to your app for live positions and trading

The version of the OpenAPI document: 1.0.0
Contact: api@snaptrade.com

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountInformationApiGenerated = exports.AccountInformationApiFactory = exports.AccountInformationApiFp = exports.AccountInformationApiAxiosParamCreator = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
const requestBeforeHook_1 = require("../requestBeforeHook");
/**
 * AccountInformationApi - axios parameter creator
 * @export
 */
const AccountInformationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns all historical transactions for the specified account.  This endpoint is paginated with a default page size of 1000. The endpoint will return a maximum of 1000 transactions per request. See the query parameters for pagination options.  Transaction are returned in reverse chronological order, using the `trade_date` field.  The data returned here is always cached and refreshed once a day.
         * @summary List account activities
         * @param {string} accountId
         * @param {string} userId
         * @param {string} userSecret
         * @param {string | Date} [startDate] The start date (inclusive) of the transaction history to retrieve. If not provided, the default is the first transaction known to SnapTrade based on &#x60;trade_date&#x60;.
         * @param {string | Date} [endDate] The end date (inclusive) of the transaction history to retrieve. If not provided, the default is the last transaction known to SnapTrade based on &#x60;trade_date&#x60;.
         * @param {number} [offset] An integer that specifies the starting point of the paginated results. Default is 0.
         * @param {number} [limit] An integer that specifies the maximum number of transactions to return. Default of 1000.
         * @param {string} [type] Optional comma separated list of transaction types to filter by. SnapTrade does a best effort to categorize brokerage transaction types into a common set of values. Here are some of the most popular values:   - &#x60;BUY&#x60; - Asset bought.   - &#x60;SELL&#x60; - Asset sold.   - &#x60;DIVIDEND&#x60; - Dividend payout.   - &#x60;CONTRIBUTION&#x60; - Cash contribution.   - &#x60;WITHDRAWAL&#x60; - Cash withdrawal.   - &#x60;REI&#x60; - Dividend reinvestment.   - &#x60;STOCK_DIVIDEND&#x60; - A type of dividend where a company distributes shares instead of cash   - &#x60;INTEREST&#x60; - Interest deposited into the account.   - &#x60;FEE&#x60; - Fee withdrawn from the account.   - &#x60;OPTIONEXPIRATION&#x60; - Option expiration event.   - &#x60;OPTIONASSIGNMENT&#x60; - Option assignment event.   - &#x60;OPTIONEXERCISE&#x60; - Option exercise event.   - &#x60;TRANSFER&#x60; - Transfer of assets from one account to another
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountActivities: (accountId, userId, userSecret, startDate, endDate, offset, limit, type, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getAccountActivities', 'accountId', accountId);
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getAccountActivities', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('getAccountActivities', 'userSecret', userSecret);
            const localVarPath = `/accounts/{accountId}/activities`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate instanceof Date) ?
                    startDate.toISOString().substr(0, 10) :
                    startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate instanceof Date) ?
                    endDate.toISOString().substr(0, 10) :
                    endDate;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/activities',
                httpMethod: 'GET'
            });
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **Deprecated, please use the account-specific holdings endpoint instead.**  List all accounts for the user, plus balances, positions, and orders for each account.
         * @summary List all accounts for the user, plus balances, positions, and orders for each account.
         * @param {string} userId
         * @param {string} userSecret
         * @param {string} [brokerageAuthorizations] Optional. Comma separated list of authorization IDs (only use if filtering is needed on one or more authorizations).
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAllUserHoldings: (userId, userSecret, brokerageAuthorizations, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getAllUserHoldings', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('getAllUserHoldings', 'userSecret', userSecret);
            const localVarPath = `/holdings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            if (brokerageAuthorizations !== undefined) {
                localVarQueryParameter['brokerage_authorizations'] = brokerageAuthorizations;
            }
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/holdings',
                httpMethod: 'GET'
            });
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of balances for the account. Each element of the list has a distinct currency. Some brokerages like Questrade [allows holding multiple currencies in the same account](https://www.questrade.com/learning/questrade-basics/balances-and-reports/understanding-your-account-balances).  The data returned here is cached. How long the data is cached for varies by brokerage. Check the [brokerage integrations doc](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v=d16c4c97b8d5438bbb2d8581ac53b11e) and look for \"Cache Expiry Time\" to see the exact value for a specific brokerage. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary List account balances
         * @param {string} userId
         * @param {string} userSecret
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountBalance: (userId, userSecret, accountId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountBalance', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountBalance', 'userSecret', userSecret);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountBalance', 'accountId', accountId);
            const localVarPath = `/accounts/{accountId}/balances`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/balances',
                httpMethod: 'GET'
            });
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns account detail known to SnapTrade for the specified account.  The data returned here is always cached and refreshed once a day. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary Get account detail
         * @param {string} userId
         * @param {string} userSecret
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountDetails: (userId, userSecret, accountId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountDetails', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountDetails', 'userSecret', userSecret);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountDetails', 'accountId', accountId);
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}',
                httpMethod: 'GET'
            });
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of recent orders in the specified account.  The data returned here is cached. How long the data is cached for varies by brokerage. Check the [brokerage integrations doc](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v=d16c4c97b8d5438bbb2d8581ac53b11e) and look for \"Cache Expiry Time\" to see the exact value for a specific brokerage. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary List account orders
         * @param {string} userId
         * @param {string} userSecret
         * @param {string} accountId
         * @param {'all' | 'open' | 'executed'} [state] defaults value is set to \&quot;all\&quot;
         * @param {number} [days] Number of days in the past to fetch the most recent orders. Defaults to the last 30 days if no value is passed in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountOrders: (userId, userSecret, accountId, state, days, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountOrders', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountOrders', 'userSecret', userSecret);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountOrders', 'accountId', accountId);
            const localVarPath = `/accounts/{accountId}/orders`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }
            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/orders',
                httpMethod: 'GET'
            });
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of stock/ETF/crypto/mutual fund positions in the specified account. For option positions, please use the [options endpoint](/reference/Options/Options_listOptionHoldings).  The data returned here is cached. How long the data is cached for varies by brokerage. Check the [brokerage integrations doc](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v=d16c4c97b8d5438bbb2d8581ac53b11e) and look for \"Cache Expiry Time\" to see the exact value for a specific brokerage. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary List account positions
         * @param {string} userId
         * @param {string} userSecret
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountPositions: (userId, userSecret, accountId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountPositions', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountPositions', 'userSecret', userSecret);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountPositions', 'accountId', accountId);
            const localVarPath = `/accounts/{accountId}/positions`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/positions',
                httpMethod: 'GET'
            });
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * A lightweight endpoint that returns a list of orders executed in the last 24 hours in the specified account. This endpoint is realtime and can be used to quickly check if account state has recently changed due to an execution, or check status of recently placed orders Differs from /orders in that it is realtime, and only checks the last 24 hours as opposed to the last 30 days By default only returns executed orders, but that can be changed by setting *only_executed* to false **Please contact support for access as this endpoint is not enabled by default.**
         * @summary List account recent orders (last 24 hours only)
         * @param {string} userId
         * @param {string} userSecret
         * @param {string} accountId
         * @param {boolean} [onlyExecuted] Defaults to true. Indicates if request should fetch only executed orders. Set to false to retrieve non executed orders as well
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountRecentOrders: (userId, userSecret, accountId, onlyExecuted, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountRecentOrders', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountRecentOrders', 'userSecret', userSecret);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountRecentOrders', 'accountId', accountId);
            const localVarPath = `/accounts/{accountId}/recentOrders`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            if (onlyExecuted !== undefined) {
                localVarQueryParameter['only_executed'] = onlyExecuted;
            }
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/recentOrders',
                httpMethod: 'GET'
            });
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of rate of return percents for a given account. Will include timeframes available from the brokerage, for example \"ALL\", \"1Y\", \"6M\", \"3M\", \"1M\"
         * @summary List account rate of returns
         * @param {string} userId
         * @param {string} userSecret
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountReturnRates: (userId, userSecret, accountId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountReturnRates', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountReturnRates', 'userSecret', userSecret);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountReturnRates', 'accountId', accountId);
            const localVarPath = `/accounts/{accountId}/returnRates`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/returnRates',
                httpMethod: 'GET'
            });
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of balances, positions, and recent orders for the specified account. The data returned is similar to the data returned over the more fine-grained [balances](/reference/Account%20Information/AccountInformation_getUserAccountBalance), [positions](/reference/Account%20Information/AccountInformation_getUserAccountPositions) and [orders](/reference/Account%20Information/AccountInformation_getUserAccountOrders) endpoints. __The finer-grained APIs are preferred. They are easier to work with, faster, and have better error handling than this coarse-grained API.__  The data returned here is cached. How long the data is cached for varies by brokerage. Check the [brokerage integrations doc](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v=d16c4c97b8d5438bbb2d8581ac53b11e) and look for \"Cache Expiry Time\" to see the exact value for a specific brokerage. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary List account holdings
         * @param {string} accountId
         * @param {string} userId
         * @param {string} userSecret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHoldings: (accountId, userId, userSecret, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getUserHoldings', 'accountId', accountId);
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getUserHoldings', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('getUserHoldings', 'userSecret', userSecret);
            const localVarPath = `/accounts/{accountId}/holdings`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/holdings',
                httpMethod: 'GET'
            });
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns all brokerage accounts across all connections known to SnapTrade for the authenticated user.  The data returned here is always cached and refreshed once a day. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary List accounts
         * @param {string} userId
         * @param {string} userSecret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAccounts: (userId, userSecret, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('listUserAccounts', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('listUserAccounts', 'userSecret', userSecret);
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts',
                httpMethod: 'GET'
            });
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates various properties of a specified account.
         * @summary Update details of an investment account
         * @param {string} userId
         * @param {string} userSecret
         * @param {string} accountId The ID of the account to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAccount: (userId, userSecret, accountId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('updateUserAccount', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('updateUserAccount', 'userSecret', userSecret);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('updateUserAccount', 'accountId', accountId);
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}',
                httpMethod: 'PUT'
            });
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AccountInformationApiAxiosParamCreator = AccountInformationApiAxiosParamCreator;
/**
 * AccountInformationApi - functional programming interface
 * @export
 */
const AccountInformationApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AccountInformationApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns all historical transactions for the specified account.  This endpoint is paginated with a default page size of 1000. The endpoint will return a maximum of 1000 transactions per request. See the query parameters for pagination options.  Transaction are returned in reverse chronological order, using the `trade_date` field.  The data returned here is always cached and refreshed once a day.
         * @summary List account activities
         * @param {AccountInformationApiGetAccountActivitiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountActivities(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccountActivities(requestParameters.accountId, requestParameters.userId, requestParameters.userSecret, requestParameters.startDate, requestParameters.endDate, requestParameters.offset, requestParameters.limit, requestParameters.type, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * **Deprecated, please use the account-specific holdings endpoint instead.**  List all accounts for the user, plus balances, positions, and orders for each account.
         * @summary List all accounts for the user, plus balances, positions, and orders for each account.
         * @param {AccountInformationApiGetAllUserHoldingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAllUserHoldings(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllUserHoldings(requestParameters.userId, requestParameters.userSecret, requestParameters.brokerageAuthorizations, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns a list of balances for the account. Each element of the list has a distinct currency. Some brokerages like Questrade [allows holding multiple currencies in the same account](https://www.questrade.com/learning/questrade-basics/balances-and-reports/understanding-your-account-balances).  The data returned here is cached. How long the data is cached for varies by brokerage. Check the [brokerage integrations doc](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v=d16c4c97b8d5438bbb2d8581ac53b11e) and look for \"Cache Expiry Time\" to see the exact value for a specific brokerage. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary List account balances
         * @param {AccountInformationApiGetUserAccountBalanceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountBalance(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserAccountBalance(requestParameters.userId, requestParameters.userSecret, requestParameters.accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns account detail known to SnapTrade for the specified account.  The data returned here is always cached and refreshed once a day. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary Get account detail
         * @param {AccountInformationApiGetUserAccountDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountDetails(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserAccountDetails(requestParameters.userId, requestParameters.userSecret, requestParameters.accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns a list of recent orders in the specified account.  The data returned here is cached. How long the data is cached for varies by brokerage. Check the [brokerage integrations doc](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v=d16c4c97b8d5438bbb2d8581ac53b11e) and look for \"Cache Expiry Time\" to see the exact value for a specific brokerage. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary List account orders
         * @param {AccountInformationApiGetUserAccountOrdersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountOrders(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserAccountOrders(requestParameters.userId, requestParameters.userSecret, requestParameters.accountId, requestParameters.state, requestParameters.days, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns a list of stock/ETF/crypto/mutual fund positions in the specified account. For option positions, please use the [options endpoint](/reference/Options/Options_listOptionHoldings).  The data returned here is cached. How long the data is cached for varies by brokerage. Check the [brokerage integrations doc](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v=d16c4c97b8d5438bbb2d8581ac53b11e) and look for \"Cache Expiry Time\" to see the exact value for a specific brokerage. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary List account positions
         * @param {AccountInformationApiGetUserAccountPositionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountPositions(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserAccountPositions(requestParameters.userId, requestParameters.userSecret, requestParameters.accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * A lightweight endpoint that returns a list of orders executed in the last 24 hours in the specified account. This endpoint is realtime and can be used to quickly check if account state has recently changed due to an execution, or check status of recently placed orders Differs from /orders in that it is realtime, and only checks the last 24 hours as opposed to the last 30 days By default only returns executed orders, but that can be changed by setting *only_executed* to false **Please contact support for access as this endpoint is not enabled by default.**
         * @summary List account recent orders (last 24 hours only)
         * @param {AccountInformationApiGetUserAccountRecentOrdersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountRecentOrders(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserAccountRecentOrders(requestParameters.userId, requestParameters.userSecret, requestParameters.accountId, requestParameters.onlyExecuted, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns a list of rate of return percents for a given account. Will include timeframes available from the brokerage, for example \"ALL\", \"1Y\", \"6M\", \"3M\", \"1M\"
         * @summary List account rate of returns
         * @param {AccountInformationApiGetUserAccountReturnRatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountReturnRates(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserAccountReturnRates(requestParameters.userId, requestParameters.userSecret, requestParameters.accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns a list of balances, positions, and recent orders for the specified account. The data returned is similar to the data returned over the more fine-grained [balances](/reference/Account%20Information/AccountInformation_getUserAccountBalance), [positions](/reference/Account%20Information/AccountInformation_getUserAccountPositions) and [orders](/reference/Account%20Information/AccountInformation_getUserAccountOrders) endpoints. __The finer-grained APIs are preferred. They are easier to work with, faster, and have better error handling than this coarse-grained API.__  The data returned here is cached. How long the data is cached for varies by brokerage. Check the [brokerage integrations doc](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v=d16c4c97b8d5438bbb2d8581ac53b11e) and look for \"Cache Expiry Time\" to see the exact value for a specific brokerage. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary List account holdings
         * @param {AccountInformationApiGetUserHoldingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHoldings(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserHoldings(requestParameters.accountId, requestParameters.userId, requestParameters.userSecret, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns all brokerage accounts across all connections known to SnapTrade for the authenticated user.  The data returned here is always cached and refreshed once a day. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary List accounts
         * @param {AccountInformationApiListUserAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAccounts(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listUserAccounts(requestParameters.userId, requestParameters.userSecret, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Updates various properties of a specified account.
         * @summary Update details of an investment account
         * @param {AccountInformationApiUpdateUserAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAccount(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserAccount(requestParameters.userId, requestParameters.userSecret, requestParameters.accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.AccountInformationApiFp = AccountInformationApiFp;
/**
 * AccountInformationApi - factory interface
 * @export
 */
const AccountInformationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AccountInformationApiFp)(configuration);
    return {
        /**
         * Returns all historical transactions for the specified account.  This endpoint is paginated with a default page size of 1000. The endpoint will return a maximum of 1000 transactions per request. See the query parameters for pagination options.  Transaction are returned in reverse chronological order, using the `trade_date` field.  The data returned here is always cached and refreshed once a day.
         * @summary List account activities
         * @param {AccountInformationApiGetAccountActivitiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountActivities(requestParameters, options) {
            return localVarFp.getAccountActivities(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * **Deprecated, please use the account-specific holdings endpoint instead.**  List all accounts for the user, plus balances, positions, and orders for each account.
         * @summary List all accounts for the user, plus balances, positions, and orders for each account.
         * @param {AccountInformationApiGetAllUserHoldingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAllUserHoldings(requestParameters, options) {
            return localVarFp.getAllUserHoldings(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of balances for the account. Each element of the list has a distinct currency. Some brokerages like Questrade [allows holding multiple currencies in the same account](https://www.questrade.com/learning/questrade-basics/balances-and-reports/understanding-your-account-balances).  The data returned here is cached. How long the data is cached for varies by brokerage. Check the [brokerage integrations doc](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v=d16c4c97b8d5438bbb2d8581ac53b11e) and look for \"Cache Expiry Time\" to see the exact value for a specific brokerage. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary List account balances
         * @param {AccountInformationApiGetUserAccountBalanceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountBalance(requestParameters, options) {
            return localVarFp.getUserAccountBalance(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns account detail known to SnapTrade for the specified account.  The data returned here is always cached and refreshed once a day. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary Get account detail
         * @param {AccountInformationApiGetUserAccountDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountDetails(requestParameters, options) {
            return localVarFp.getUserAccountDetails(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of recent orders in the specified account.  The data returned here is cached. How long the data is cached for varies by brokerage. Check the [brokerage integrations doc](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v=d16c4c97b8d5438bbb2d8581ac53b11e) and look for \"Cache Expiry Time\" to see the exact value for a specific brokerage. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary List account orders
         * @param {AccountInformationApiGetUserAccountOrdersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountOrders(requestParameters, options) {
            return localVarFp.getUserAccountOrders(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of stock/ETF/crypto/mutual fund positions in the specified account. For option positions, please use the [options endpoint](/reference/Options/Options_listOptionHoldings).  The data returned here is cached. How long the data is cached for varies by brokerage. Check the [brokerage integrations doc](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v=d16c4c97b8d5438bbb2d8581ac53b11e) and look for \"Cache Expiry Time\" to see the exact value for a specific brokerage. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary List account positions
         * @param {AccountInformationApiGetUserAccountPositionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountPositions(requestParameters, options) {
            return localVarFp.getUserAccountPositions(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * A lightweight endpoint that returns a list of orders executed in the last 24 hours in the specified account. This endpoint is realtime and can be used to quickly check if account state has recently changed due to an execution, or check status of recently placed orders Differs from /orders in that it is realtime, and only checks the last 24 hours as opposed to the last 30 days By default only returns executed orders, but that can be changed by setting *only_executed* to false **Please contact support for access as this endpoint is not enabled by default.**
         * @summary List account recent orders (last 24 hours only)
         * @param {AccountInformationApiGetUserAccountRecentOrdersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountRecentOrders(requestParameters, options) {
            return localVarFp.getUserAccountRecentOrders(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of rate of return percents for a given account. Will include timeframes available from the brokerage, for example \"ALL\", \"1Y\", \"6M\", \"3M\", \"1M\"
         * @summary List account rate of returns
         * @param {AccountInformationApiGetUserAccountReturnRatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountReturnRates(requestParameters, options) {
            return localVarFp.getUserAccountReturnRates(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of balances, positions, and recent orders for the specified account. The data returned is similar to the data returned over the more fine-grained [balances](/reference/Account%20Information/AccountInformation_getUserAccountBalance), [positions](/reference/Account%20Information/AccountInformation_getUserAccountPositions) and [orders](/reference/Account%20Information/AccountInformation_getUserAccountOrders) endpoints. __The finer-grained APIs are preferred. They are easier to work with, faster, and have better error handling than this coarse-grained API.__  The data returned here is cached. How long the data is cached for varies by brokerage. Check the [brokerage integrations doc](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v=d16c4c97b8d5438bbb2d8581ac53b11e) and look for \"Cache Expiry Time\" to see the exact value for a specific brokerage. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary List account holdings
         * @param {AccountInformationApiGetUserHoldingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHoldings(requestParameters, options) {
            return localVarFp.getUserHoldings(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all brokerage accounts across all connections known to SnapTrade for the authenticated user.  The data returned here is always cached and refreshed once a day. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
         * @summary List accounts
         * @param {AccountInformationApiListUserAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAccounts(requestParameters, options) {
            return localVarFp.listUserAccounts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates various properties of a specified account.
         * @summary Update details of an investment account
         * @param {AccountInformationApiUpdateUserAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAccount(requestParameters, options) {
            return localVarFp.updateUserAccount(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AccountInformationApiFactory = AccountInformationApiFactory;
/**
 * AccountInformationApiGenerated - object-oriented interface
 * @export
 * @class AccountInformationApiGenerated
 * @extends {BaseAPI}
 */
class AccountInformationApiGenerated extends base_1.BaseAPI {
    /**
     * Returns all historical transactions for the specified account.  This endpoint is paginated with a default page size of 1000. The endpoint will return a maximum of 1000 transactions per request. See the query parameters for pagination options.  Transaction are returned in reverse chronological order, using the `trade_date` field.  The data returned here is always cached and refreshed once a day.
     * @summary List account activities
     * @param {AccountInformationApiGetAccountActivitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApiGenerated
     */
    getAccountActivities(requestParameters, options) {
        return (0, exports.AccountInformationApiFp)(this.configuration).getAccountActivities(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **Deprecated, please use the account-specific holdings endpoint instead.**  List all accounts for the user, plus balances, positions, and orders for each account.
     * @summary List all accounts for the user, plus balances, positions, and orders for each account.
     * @param {AccountInformationApiGetAllUserHoldingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AccountInformationApiGenerated
     */
    getAllUserHoldings(requestParameters, options) {
        return (0, exports.AccountInformationApiFp)(this.configuration).getAllUserHoldings(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of balances for the account. Each element of the list has a distinct currency. Some brokerages like Questrade [allows holding multiple currencies in the same account](https://www.questrade.com/learning/questrade-basics/balances-and-reports/understanding-your-account-balances).  The data returned here is cached. How long the data is cached for varies by brokerage. Check the [brokerage integrations doc](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v=d16c4c97b8d5438bbb2d8581ac53b11e) and look for \"Cache Expiry Time\" to see the exact value for a specific brokerage. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
     * @summary List account balances
     * @param {AccountInformationApiGetUserAccountBalanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApiGenerated
     */
    getUserAccountBalance(requestParameters, options) {
        return (0, exports.AccountInformationApiFp)(this.configuration).getUserAccountBalance(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns account detail known to SnapTrade for the specified account.  The data returned here is always cached and refreshed once a day. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
     * @summary Get account detail
     * @param {AccountInformationApiGetUserAccountDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApiGenerated
     */
    getUserAccountDetails(requestParameters, options) {
        return (0, exports.AccountInformationApiFp)(this.configuration).getUserAccountDetails(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of recent orders in the specified account.  The data returned here is cached. How long the data is cached for varies by brokerage. Check the [brokerage integrations doc](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v=d16c4c97b8d5438bbb2d8581ac53b11e) and look for \"Cache Expiry Time\" to see the exact value for a specific brokerage. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
     * @summary List account orders
     * @param {AccountInformationApiGetUserAccountOrdersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApiGenerated
     */
    getUserAccountOrders(requestParameters, options) {
        return (0, exports.AccountInformationApiFp)(this.configuration).getUserAccountOrders(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of stock/ETF/crypto/mutual fund positions in the specified account. For option positions, please use the [options endpoint](/reference/Options/Options_listOptionHoldings).  The data returned here is cached. How long the data is cached for varies by brokerage. Check the [brokerage integrations doc](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v=d16c4c97b8d5438bbb2d8581ac53b11e) and look for \"Cache Expiry Time\" to see the exact value for a specific brokerage. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
     * @summary List account positions
     * @param {AccountInformationApiGetUserAccountPositionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApiGenerated
     */
    getUserAccountPositions(requestParameters, options) {
        return (0, exports.AccountInformationApiFp)(this.configuration).getUserAccountPositions(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * A lightweight endpoint that returns a list of orders executed in the last 24 hours in the specified account. This endpoint is realtime and can be used to quickly check if account state has recently changed due to an execution, or check status of recently placed orders Differs from /orders in that it is realtime, and only checks the last 24 hours as opposed to the last 30 days By default only returns executed orders, but that can be changed by setting *only_executed* to false **Please contact support for access as this endpoint is not enabled by default.**
     * @summary List account recent orders (last 24 hours only)
     * @param {AccountInformationApiGetUserAccountRecentOrdersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApiGenerated
     */
    getUserAccountRecentOrders(requestParameters, options) {
        return (0, exports.AccountInformationApiFp)(this.configuration).getUserAccountRecentOrders(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of rate of return percents for a given account. Will include timeframes available from the brokerage, for example \"ALL\", \"1Y\", \"6M\", \"3M\", \"1M\"
     * @summary List account rate of returns
     * @param {AccountInformationApiGetUserAccountReturnRatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApiGenerated
     */
    getUserAccountReturnRates(requestParameters, options) {
        return (0, exports.AccountInformationApiFp)(this.configuration).getUserAccountReturnRates(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of balances, positions, and recent orders for the specified account. The data returned is similar to the data returned over the more fine-grained [balances](/reference/Account%20Information/AccountInformation_getUserAccountBalance), [positions](/reference/Account%20Information/AccountInformation_getUserAccountPositions) and [orders](/reference/Account%20Information/AccountInformation_getUserAccountOrders) endpoints. __The finer-grained APIs are preferred. They are easier to work with, faster, and have better error handling than this coarse-grained API.__  The data returned here is cached. How long the data is cached for varies by brokerage. Check the [brokerage integrations doc](https://snaptrade.notion.site/66793431ad0b416489eaabaf248d0afb?v=d16c4c97b8d5438bbb2d8581ac53b11e) and look for \"Cache Expiry Time\" to see the exact value for a specific brokerage. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
     * @summary List account holdings
     * @param {AccountInformationApiGetUserHoldingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApiGenerated
     */
    getUserHoldings(requestParameters, options) {
        return (0, exports.AccountInformationApiFp)(this.configuration).getUserHoldings(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all brokerage accounts across all connections known to SnapTrade for the authenticated user.  The data returned here is always cached and refreshed once a day. **If you need real-time data, please use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint**.
     * @summary List accounts
     * @param {AccountInformationApiListUserAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApiGenerated
     */
    listUserAccounts(requestParameters, options) {
        return (0, exports.AccountInformationApiFp)(this.configuration).listUserAccounts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates various properties of a specified account.
     * @summary Update details of an investment account
     * @param {AccountInformationApiUpdateUserAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApiGenerated
     */
    updateUserAccount(requestParameters, options) {
        return (0, exports.AccountInformationApiFp)(this.configuration).updateUserAccount(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AccountInformationApiGenerated = AccountInformationApiGenerated;
