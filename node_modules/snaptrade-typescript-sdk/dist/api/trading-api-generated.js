"use strict";
/* tslint:disable */
/* eslint-disable */
/*
SnapTrade

Connect brokerage accounts to your app for live positions and trading

The version of the OpenAPI document: 1.0.0
Contact: api@snaptrade.com

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TradingApiGenerated = exports.TradingApiFactory = exports.TradingApiFp = exports.TradingApiAxiosParamCreator = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
const requestBeforeHook_1 = require("../requestBeforeHook");
/**
 * TradingApi - axios parameter creator
 * @export
 */
const TradingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Cancels an order in the specified account. Accepts order IDs for all asset types.
         * @summary Cancel order
         * @param {string} userId
         * @param {string} userSecret
         * @param {string} accountId
         * @param {TradingCancelUserAccountOrderRequest} tradingCancelUserAccountOrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder: (userId, userSecret, accountId, tradingCancelUserAccountOrderRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('cancelOrder', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('cancelOrder', 'userSecret', userSecret);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('cancelOrder', 'accountId', accountId);
            // verify required parameter 'tradingCancelUserAccountOrderRequest' is not null or undefined
            (0, common_1.assertParamExists)('cancelOrder', 'tradingCancelUserAccountOrderRequest', tradingCancelUserAccountOrderRequest);
            const localVarPath = `/accounts/{accountId}/trading/cancel`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                requestBody: tradingCancelUserAccountOrderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/trading/cancel',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(tradingCancelUserAccountOrderRequest, localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint is deprecated. Please switch to [the new cancel order endpoint](/reference/Trading/Trading_cancelOrder) ** Attempts to cancel an open order with the brokerage. If the order is no longer cancellable, the request will be rejected.
         * @summary Cancel equity order
         * @param {string} userId
         * @param {string} userSecret
         * @param {string} accountId
         * @param {TradingCancelUserAccountOrderRequest} tradingCancelUserAccountOrderRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        cancelUserAccountOrder: (userId, userSecret, accountId, tradingCancelUserAccountOrderRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('cancelUserAccountOrder', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('cancelUserAccountOrder', 'userSecret', userSecret);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('cancelUserAccountOrder', 'accountId', accountId);
            // verify required parameter 'tradingCancelUserAccountOrderRequest' is not null or undefined
            (0, common_1.assertParamExists)('cancelUserAccountOrder', 'tradingCancelUserAccountOrderRequest', tradingCancelUserAccountOrderRequest);
            const localVarPath = `/accounts/{accountId}/orders/cancel`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                requestBody: tradingCancelUserAccountOrderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/orders/cancel',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(tradingCancelUserAccountOrderRequest, localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Gets a quote for the specified account.
         * @summary Get crypto pair quote
         * @param {string} userId
         * @param {string} userSecret
         * @param {string} accountId
         * @param {string} instrumentSymbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptocurrencyPairQuote: (userId, userSecret, accountId, instrumentSymbol, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getCryptocurrencyPairQuote', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('getCryptocurrencyPairQuote', 'userSecret', userSecret);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getCryptocurrencyPairQuote', 'accountId', accountId);
            // verify required parameter 'instrumentSymbol' is not null or undefined
            (0, common_1.assertParamExists)('getCryptocurrencyPairQuote', 'instrumentSymbol', instrumentSymbol);
            const localVarPath = `/accounts/{accountId}/trading/instruments/cryptocurrencyPairs/{instrumentSymbol}/quote`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)))
                .replace(`{${"instrumentSymbol"}}`, encodeURIComponent(String(instrumentSymbol !== undefined ? instrumentSymbol : `-instrumentSymbol-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/trading/instruments/cryptocurrencyPairs/{instrumentSymbol}/quote',
                httpMethod: 'GET'
            });
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Simulates an order and its impact on the account. This endpoint does not place the order with the brokerage. If successful, it returns a `Trade` object and the ID of the object can be used to place the order with the brokerage using the [place checked order endpoint](/reference/Trading/Trading_placeOrder). Please note that the `Trade` object returned expires after 5 minutes. Any order placed using an expired `Trade` will be rejected.
         * @summary Check equity order impact
         * @param {string} userId
         * @param {string} userSecret
         * @param {ManualTradeForm} manualTradeForm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderImpact: (userId, userSecret, manualTradeForm, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getOrderImpact', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('getOrderImpact', 'userSecret', userSecret);
            // verify required parameter 'manualTradeForm' is not null or undefined
            (0, common_1.assertParamExists)('getOrderImpact', 'manualTradeForm', manualTradeForm);
            const localVarPath = `/trade/impact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                requestBody: manualTradeForm,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/trade/impact',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(manualTradeForm, localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns quotes from the brokerage for the specified symbols and account. The quotes returned can be delayed depending on the brokerage the account belongs to. It is highly recommended that you use your own market data provider for real-time quotes instead of relying on this endpoint. This endpoint does not work for options quotes.
         * @summary Get equity symbol quotes
         * @param {string} userId
         * @param {string} userSecret
         * @param {string} symbols List of Universal Symbol IDs or tickers to get quotes for. When providing multiple values, use a comma as separator
         * @param {string} accountId
         * @param {boolean} [useTicker] Should be set to &#x60;True&#x60; if &#x60;symbols&#x60; are comprised of tickers. Defaults to &#x60;False&#x60; if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountQuotes: (userId, userSecret, symbols, accountId, useTicker, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountQuotes', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountQuotes', 'userSecret', userSecret);
            // verify required parameter 'symbols' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountQuotes', 'symbols', symbols);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getUserAccountQuotes', 'accountId', accountId);
            const localVarPath = `/accounts/{accountId}/quotes`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }
            if (useTicker !== undefined) {
                localVarQueryParameter['use_ticker'] = useTicker;
            }
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/quotes',
                httpMethod: 'GET'
            });
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Places a bracket order (entry order + OCO of stop loss and take profit). Disabled by default please contact support for use. Only supported on certain brokerages
         * @summary Place bracket equity order
         * @param {string} accountId The ID of the account to execute the trade on.
         * @param {string} userId
         * @param {string} userSecret
         * @param {ManualTradeFormBracket} manualTradeFormBracket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeBracketOrder: (accountId, userId, userSecret, manualTradeFormBracket, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('placeBracketOrder', 'accountId', accountId);
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('placeBracketOrder', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('placeBracketOrder', 'userSecret', userSecret);
            // verify required parameter 'manualTradeFormBracket' is not null or undefined
            (0, common_1.assertParamExists)('placeBracketOrder', 'manualTradeFormBracket', manualTradeFormBracket);
            const localVarPath = `/accounts/{accountId}/trading/bracket`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                requestBody: manualTradeFormBracket,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/trading/bracket',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(manualTradeFormBracket, localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Places an order in the specified account. This endpoint does not compute the impact to the account balance from the order before submitting the order.
         * @summary Place crypto order
         * @param {string} userId
         * @param {string} userSecret
         * @param {string} accountId
         * @param {CryptoOrderForm} cryptoOrderForm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeCryptoOrder: (userId, userSecret, accountId, cryptoOrderForm, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('placeCryptoOrder', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('placeCryptoOrder', 'userSecret', userSecret);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('placeCryptoOrder', 'accountId', accountId);
            // verify required parameter 'cryptoOrderForm' is not null or undefined
            (0, common_1.assertParamExists)('placeCryptoOrder', 'cryptoOrderForm', cryptoOrderForm);
            const localVarPath = `/accounts/{accountId}/trading/crypto`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                requestBody: cryptoOrderForm,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/trading/crypto',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(cryptoOrderForm, localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Places a brokerage order in the specified account. The order could be rejected by the brokerage if it is invalid or if the account does not have sufficient funds.  This endpoint does not compute the impact to the account balance from the order and any potential commissions before submitting the order to the brokerage. If that is desired, you can use the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact).  It\'s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
         * @summary Place order
         * @param {string} userId
         * @param {string} userSecret
         * @param {ManualTradeFormWithOptions} manualTradeFormWithOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeForceOrder: (userId, userSecret, manualTradeFormWithOptions, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('placeForceOrder', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('placeForceOrder', 'userSecret', userSecret);
            // verify required parameter 'manualTradeFormWithOptions' is not null or undefined
            (0, common_1.assertParamExists)('placeForceOrder', 'manualTradeFormWithOptions', manualTradeFormWithOptions);
            const localVarPath = `/trade/place`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                requestBody: manualTradeFormWithOptions,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/trade/place',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(manualTradeFormWithOptions, localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Places a multi-leg option order. Only supported on certain option trading brokerages. https://snaptrade.notion.site/brokerages has information on brokerage trading support
         * @summary Place option order
         * @param {string} userId
         * @param {string} userSecret
         * @param {string} accountId
         * @param {MlegTradeForm} mlegTradeForm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeMlegOrder: (userId, userSecret, accountId, mlegTradeForm, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('placeMlegOrder', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('placeMlegOrder', 'userSecret', userSecret);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('placeMlegOrder', 'accountId', accountId);
            // verify required parameter 'mlegTradeForm' is not null or undefined
            (0, common_1.assertParamExists)('placeMlegOrder', 'mlegTradeForm', mlegTradeForm);
            const localVarPath = `/accounts/{accountId}/trading/options`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                requestBody: mlegTradeForm,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/trading/options',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(mlegTradeForm, localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Places the previously checked order with the brokerage. The `tradeId` is obtained from the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact). If you prefer to place the order without checking for impact first, you can use the [place order endpoint](/reference/Trading/Trading_placeForceOrder).  It\'s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
         * @summary Place checked equity order
         * @param {string} tradeId Obtained from calling the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact)
         * @param {string} userId
         * @param {string} userSecret
         * @param {ValidatedTradeBody} [validatedTradeBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOrder: (tradeId, userId, userSecret, validatedTradeBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'tradeId' is not null or undefined
            (0, common_1.assertParamExists)('placeOrder', 'tradeId', tradeId);
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('placeOrder', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('placeOrder', 'userSecret', userSecret);
            const localVarPath = `/trade/{tradeId}`
                .replace(`{${"tradeId"}}`, encodeURIComponent(String(tradeId !== undefined ? tradeId : `-tradeId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                requestBody: validatedTradeBody,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/trade/{tradeId}',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(validatedTradeBody, localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Previews an order using the specified account.
         * @summary Preview crypto order
         * @param {string} userId
         * @param {string} userSecret
         * @param {string} accountId
         * @param {CryptoOrderForm} cryptoOrderForm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewCryptoOrder: (userId, userSecret, accountId, cryptoOrderForm, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('previewCryptoOrder', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('previewCryptoOrder', 'userSecret', userSecret);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('previewCryptoOrder', 'accountId', accountId);
            // verify required parameter 'cryptoOrderForm' is not null or undefined
            (0, common_1.assertParamExists)('previewCryptoOrder', 'cryptoOrderForm', cryptoOrderForm);
            const localVarPath = `/accounts/{accountId}/trading/crypto/preview`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                requestBody: cryptoOrderForm,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/trading/crypto/preview',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(cryptoOrderForm, localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Replaces an existing pending order with a new one. The way this works is brokerage dependent, but usually involves cancelling the existing order and placing a new one. The order\'s brokerage_order_id may or may not change, be sure to use the one returned in the response going forward. Only supported on some brokerages
         * @summary Replace order
         * @param {string} accountId The ID of the account to execute the trade on.
         * @param {string} userId
         * @param {string} userSecret
         * @param {ManualTradeReplaceForm} manualTradeReplaceForm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrder: (accountId, userId, userSecret, manualTradeReplaceForm, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('replaceOrder', 'accountId', accountId);
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('replaceOrder', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('replaceOrder', 'userSecret', userSecret);
            // verify required parameter 'manualTradeReplaceForm' is not null or undefined
            (0, common_1.assertParamExists)('replaceOrder', 'manualTradeReplaceForm', manualTradeReplaceForm);
            const localVarPath = `/accounts/{accountId}/trading/replace`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                requestBody: manualTradeReplaceForm,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/trading/replace',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(manualTradeReplaceForm, localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Searches cryptocurrency pairs instruments accessible to the specified account.
         * @summary Get crypto pairs
         * @param {string} userId
         * @param {string} userSecret
         * @param {string} accountId
         * @param {string} [base]
         * @param {string} [quote]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCryptocurrencyPairInstruments: (userId, userSecret, accountId, base, quote, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('searchCryptocurrencyPairInstruments', 'userId', userId);
            // verify required parameter 'userSecret' is not null or undefined
            (0, common_1.assertParamExists)('searchCryptocurrencyPairInstruments', 'userSecret', userSecret);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('searchCryptocurrencyPairInstruments', 'accountId', accountId);
            const localVarPath = `/accounts/{accountId}/trading/instruments/cryptocurrencyPairs`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId !== undefined ? accountId : `-accountId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = configuration && !(0, common_1.isBrowser)() ? { "User-Agent": configuration.userAgent } : {};
            const localVarQueryParameter = {};
            // authentication PartnerClientId required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "clientId", keyParamName: "clientId", configuration });
            // authentication PartnerSignature required
            yield (0, common_1.setApiKeyToObject)({ object: localVarHeaderParameter, key: "Signature", keyParamName: "signature", configuration });
            // authentication PartnerTimestamp required
            yield (0, common_1.setApiKeyToObject)({ object: localVarQueryParameter, key: "timestamp", keyParamName: "timestamp", configuration });
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }
            if (base !== undefined) {
                localVarQueryParameter['base'] = base;
            }
            if (quote !== undefined) {
                localVarQueryParameter['quote'] = quote;
            }
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            (0, requestBeforeHook_1.requestBeforeHook)({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/accounts/{accountId}/trading/instruments/cryptocurrencyPairs',
                httpMethod: 'GET'
            });
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TradingApiAxiosParamCreator = TradingApiAxiosParamCreator;
/**
 * TradingApi - functional programming interface
 * @export
 */
const TradingApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TradingApiAxiosParamCreator)(configuration);
    return {
        /**
         * Cancels an order in the specified account. Accepts order IDs for all asset types.
         * @summary Cancel order
         * @param {TradingApiCancelOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const tradingCancelUserAccountOrderRequest = {
                    brokerage_order_id: requestParameters.brokerage_order_id
                };
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelOrder(requestParameters.userId, requestParameters.userSecret, requestParameters.accountId, tradingCancelUserAccountOrderRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * **This endpoint is deprecated. Please switch to [the new cancel order endpoint](/reference/Trading/Trading_cancelOrder) ** Attempts to cancel an open order with the brokerage. If the order is no longer cancellable, the request will be rejected.
         * @summary Cancel equity order
         * @param {TradingApiCancelUserAccountOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        cancelUserAccountOrder(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const tradingCancelUserAccountOrderRequest = {
                    brokerage_order_id: requestParameters.brokerage_order_id
                };
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelUserAccountOrder(requestParameters.userId, requestParameters.userSecret, requestParameters.accountId, tradingCancelUserAccountOrderRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Gets a quote for the specified account.
         * @summary Get crypto pair quote
         * @param {TradingApiGetCryptocurrencyPairQuoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptocurrencyPairQuote(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCryptocurrencyPairQuote(requestParameters.userId, requestParameters.userSecret, requestParameters.accountId, requestParameters.instrumentSymbol, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Simulates an order and its impact on the account. This endpoint does not place the order with the brokerage. If successful, it returns a `Trade` object and the ID of the object can be used to place the order with the brokerage using the [place checked order endpoint](/reference/Trading/Trading_placeOrder). Please note that the `Trade` object returned expires after 5 minutes. Any order placed using an expired `Trade` will be rejected.
         * @summary Check equity order impact
         * @param {TradingApiGetOrderImpactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderImpact(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const manualTradeForm = {
                    account_id: requestParameters.account_id,
                    action: requestParameters.action,
                    universal_symbol_id: requestParameters.universal_symbol_id,
                    order_type: requestParameters.order_type,
                    time_in_force: requestParameters.time_in_force,
                    price: requestParameters.price,
                    stop: requestParameters.stop,
                    units: requestParameters.units,
                    notional_value: requestParameters.notional_value
                };
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrderImpact(requestParameters.userId, requestParameters.userSecret, manualTradeForm, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns quotes from the brokerage for the specified symbols and account. The quotes returned can be delayed depending on the brokerage the account belongs to. It is highly recommended that you use your own market data provider for real-time quotes instead of relying on this endpoint. This endpoint does not work for options quotes.
         * @summary Get equity symbol quotes
         * @param {TradingApiGetUserAccountQuotesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountQuotes(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserAccountQuotes(requestParameters.userId, requestParameters.userSecret, requestParameters.symbols, requestParameters.accountId, requestParameters.useTicker, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Places a bracket order (entry order + OCO of stop loss and take profit). Disabled by default please contact support for use. Only supported on certain brokerages
         * @summary Place bracket equity order
         * @param {TradingApiPlaceBracketOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeBracketOrder(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const manualTradeFormBracket = {
                    action: requestParameters.action,
                    symbol: requestParameters.symbol,
                    instrument: requestParameters.instrument,
                    order_type: requestParameters.order_type,
                    time_in_force: requestParameters.time_in_force,
                    price: requestParameters.price,
                    stop: requestParameters.stop,
                    units: requestParameters.units,
                    stop_loss: requestParameters.stop_loss,
                    take_profit: requestParameters.take_profit
                };
                const localVarAxiosArgs = yield localVarAxiosParamCreator.placeBracketOrder(requestParameters.accountId, requestParameters.userId, requestParameters.userSecret, manualTradeFormBracket, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Places an order in the specified account. This endpoint does not compute the impact to the account balance from the order before submitting the order.
         * @summary Place crypto order
         * @param {TradingApiPlaceCryptoOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeCryptoOrder(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const cryptoOrderForm = {
                    instrument: requestParameters.instrument,
                    side: requestParameters.side,
                    type: requestParameters.type,
                    time_in_force: requestParameters.time_in_force,
                    amount: requestParameters.amount,
                    limit_price: requestParameters.limit_price,
                    stop_price: requestParameters.stop_price,
                    post_only: requestParameters.post_only,
                    expiration_date: requestParameters.expiration_date
                };
                const localVarAxiosArgs = yield localVarAxiosParamCreator.placeCryptoOrder(requestParameters.userId, requestParameters.userSecret, requestParameters.accountId, cryptoOrderForm, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Places a brokerage order in the specified account. The order could be rejected by the brokerage if it is invalid or if the account does not have sufficient funds.  This endpoint does not compute the impact to the account balance from the order and any potential commissions before submitting the order to the brokerage. If that is desired, you can use the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact).  It\'s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
         * @summary Place order
         * @param {TradingApiPlaceForceOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeForceOrder(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const manualTradeFormWithOptions = {
                    account_id: requestParameters.account_id,
                    action: requestParameters.action,
                    universal_symbol_id: requestParameters.universal_symbol_id,
                    symbol: requestParameters.symbol,
                    order_type: requestParameters.order_type,
                    time_in_force: requestParameters.time_in_force,
                    price: requestParameters.price,
                    stop: requestParameters.stop,
                    units: requestParameters.units,
                    notional_value: requestParameters.notional_value
                };
                const localVarAxiosArgs = yield localVarAxiosParamCreator.placeForceOrder(requestParameters.userId, requestParameters.userSecret, manualTradeFormWithOptions, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Places a multi-leg option order. Only supported on certain option trading brokerages. https://snaptrade.notion.site/brokerages has information on brokerage trading support
         * @summary Place option order
         * @param {TradingApiPlaceMlegOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeMlegOrder(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const mlegTradeForm = {
                    order_type: requestParameters.order_type,
                    time_in_force: requestParameters.time_in_force,
                    limit_price: requestParameters.limit_price,
                    stop_price: requestParameters.stop_price,
                    price_effect: requestParameters.price_effect,
                    legs: requestParameters.legs
                };
                const localVarAxiosArgs = yield localVarAxiosParamCreator.placeMlegOrder(requestParameters.userId, requestParameters.userSecret, requestParameters.accountId, mlegTradeForm, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Places the previously checked order with the brokerage. The `tradeId` is obtained from the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact). If you prefer to place the order without checking for impact first, you can use the [place order endpoint](/reference/Trading/Trading_placeForceOrder).  It\'s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
         * @summary Place checked equity order
         * @param {TradingApiPlaceOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOrder(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const validatedTradeBody = {
                    wait_to_confirm: requestParameters.wait_to_confirm
                };
                const localVarAxiosArgs = yield localVarAxiosParamCreator.placeOrder(requestParameters.tradeId, requestParameters.userId, requestParameters.userSecret, validatedTradeBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Previews an order using the specified account.
         * @summary Preview crypto order
         * @param {TradingApiPreviewCryptoOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewCryptoOrder(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const cryptoOrderForm = {
                    instrument: requestParameters.instrument,
                    side: requestParameters.side,
                    type: requestParameters.type,
                    time_in_force: requestParameters.time_in_force,
                    amount: requestParameters.amount,
                    limit_price: requestParameters.limit_price,
                    stop_price: requestParameters.stop_price,
                    post_only: requestParameters.post_only,
                    expiration_date: requestParameters.expiration_date
                };
                const localVarAxiosArgs = yield localVarAxiosParamCreator.previewCryptoOrder(requestParameters.userId, requestParameters.userSecret, requestParameters.accountId, cryptoOrderForm, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Replaces an existing pending order with a new one. The way this works is brokerage dependent, but usually involves cancelling the existing order and placing a new one. The order\'s brokerage_order_id may or may not change, be sure to use the one returned in the response going forward. Only supported on some brokerages
         * @summary Replace order
         * @param {TradingApiReplaceOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrder(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const manualTradeReplaceForm = {
                    brokerage_order_id: requestParameters.brokerage_order_id,
                    action: requestParameters.action,
                    order_type: requestParameters.order_type,
                    time_in_force: requestParameters.time_in_force,
                    price: requestParameters.price,
                    symbol: requestParameters.symbol,
                    stop: requestParameters.stop,
                    units: requestParameters.units
                };
                const localVarAxiosArgs = yield localVarAxiosParamCreator.replaceOrder(requestParameters.accountId, requestParameters.userId, requestParameters.userSecret, manualTradeReplaceForm, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Searches cryptocurrency pairs instruments accessible to the specified account.
         * @summary Get crypto pairs
         * @param {TradingApiSearchCryptocurrencyPairInstrumentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCryptocurrencyPairInstruments(requestParameters, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchCryptocurrencyPairInstruments(requestParameters.userId, requestParameters.userSecret, requestParameters.accountId, requestParameters.base, requestParameters.quote, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TradingApiFp = TradingApiFp;
/**
 * TradingApi - factory interface
 * @export
 */
const TradingApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TradingApiFp)(configuration);
    return {
        /**
         * Cancels an order in the specified account. Accepts order IDs for all asset types.
         * @summary Cancel order
         * @param {TradingApiCancelOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(requestParameters, options) {
            return localVarFp.cancelOrder(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint is deprecated. Please switch to [the new cancel order endpoint](/reference/Trading/Trading_cancelOrder) ** Attempts to cancel an open order with the brokerage. If the order is no longer cancellable, the request will be rejected.
         * @summary Cancel equity order
         * @param {TradingApiCancelUserAccountOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        cancelUserAccountOrder(requestParameters, options) {
            return localVarFp.cancelUserAccountOrder(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a quote for the specified account.
         * @summary Get crypto pair quote
         * @param {TradingApiGetCryptocurrencyPairQuoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptocurrencyPairQuote(requestParameters, options) {
            return localVarFp.getCryptocurrencyPairQuote(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Simulates an order and its impact on the account. This endpoint does not place the order with the brokerage. If successful, it returns a `Trade` object and the ID of the object can be used to place the order with the brokerage using the [place checked order endpoint](/reference/Trading/Trading_placeOrder). Please note that the `Trade` object returned expires after 5 minutes. Any order placed using an expired `Trade` will be rejected.
         * @summary Check equity order impact
         * @param {TradingApiGetOrderImpactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderImpact(requestParameters, options) {
            return localVarFp.getOrderImpact(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns quotes from the brokerage for the specified symbols and account. The quotes returned can be delayed depending on the brokerage the account belongs to. It is highly recommended that you use your own market data provider for real-time quotes instead of relying on this endpoint. This endpoint does not work for options quotes.
         * @summary Get equity symbol quotes
         * @param {TradingApiGetUserAccountQuotesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountQuotes(requestParameters, options) {
            return localVarFp.getUserAccountQuotes(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Places a bracket order (entry order + OCO of stop loss and take profit). Disabled by default please contact support for use. Only supported on certain brokerages
         * @summary Place bracket equity order
         * @param {TradingApiPlaceBracketOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeBracketOrder(requestParameters, options) {
            return localVarFp.placeBracketOrder(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Places an order in the specified account. This endpoint does not compute the impact to the account balance from the order before submitting the order.
         * @summary Place crypto order
         * @param {TradingApiPlaceCryptoOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeCryptoOrder(requestParameters, options) {
            return localVarFp.placeCryptoOrder(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Places a brokerage order in the specified account. The order could be rejected by the brokerage if it is invalid or if the account does not have sufficient funds.  This endpoint does not compute the impact to the account balance from the order and any potential commissions before submitting the order to the brokerage. If that is desired, you can use the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact).  It\'s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
         * @summary Place order
         * @param {TradingApiPlaceForceOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeForceOrder(requestParameters, options) {
            return localVarFp.placeForceOrder(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Places a multi-leg option order. Only supported on certain option trading brokerages. https://snaptrade.notion.site/brokerages has information on brokerage trading support
         * @summary Place option order
         * @param {TradingApiPlaceMlegOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeMlegOrder(requestParameters, options) {
            return localVarFp.placeMlegOrder(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Places the previously checked order with the brokerage. The `tradeId` is obtained from the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact). If you prefer to place the order without checking for impact first, you can use the [place order endpoint](/reference/Trading/Trading_placeForceOrder).  It\'s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
         * @summary Place checked equity order
         * @param {TradingApiPlaceOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOrder(requestParameters, options) {
            return localVarFp.placeOrder(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Previews an order using the specified account.
         * @summary Preview crypto order
         * @param {TradingApiPreviewCryptoOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewCryptoOrder(requestParameters, options) {
            return localVarFp.previewCryptoOrder(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces an existing pending order with a new one. The way this works is brokerage dependent, but usually involves cancelling the existing order and placing a new one. The order\'s brokerage_order_id may or may not change, be sure to use the one returned in the response going forward. Only supported on some brokerages
         * @summary Replace order
         * @param {TradingApiReplaceOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrder(requestParameters, options) {
            return localVarFp.replaceOrder(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches cryptocurrency pairs instruments accessible to the specified account.
         * @summary Get crypto pairs
         * @param {TradingApiSearchCryptocurrencyPairInstrumentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCryptocurrencyPairInstruments(requestParameters, options) {
            return localVarFp.searchCryptocurrencyPairInstruments(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TradingApiFactory = TradingApiFactory;
/**
 * TradingApiGenerated - object-oriented interface
 * @export
 * @class TradingApiGenerated
 * @extends {BaseAPI}
 */
class TradingApiGenerated extends base_1.BaseAPI {
    /**
     * Cancels an order in the specified account. Accepts order IDs for all asset types.
     * @summary Cancel order
     * @param {TradingApiCancelOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    cancelOrder(requestParameters, options) {
        return (0, exports.TradingApiFp)(this.configuration).cancelOrder(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint is deprecated. Please switch to [the new cancel order endpoint](/reference/Trading/Trading_cancelOrder) ** Attempts to cancel an open order with the brokerage. If the order is no longer cancellable, the request will be rejected.
     * @summary Cancel equity order
     * @param {TradingApiCancelUserAccountOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    cancelUserAccountOrder(requestParameters, options) {
        return (0, exports.TradingApiFp)(this.configuration).cancelUserAccountOrder(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets a quote for the specified account.
     * @summary Get crypto pair quote
     * @param {TradingApiGetCryptocurrencyPairQuoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    getCryptocurrencyPairQuote(requestParameters, options) {
        return (0, exports.TradingApiFp)(this.configuration).getCryptocurrencyPairQuote(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Simulates an order and its impact on the account. This endpoint does not place the order with the brokerage. If successful, it returns a `Trade` object and the ID of the object can be used to place the order with the brokerage using the [place checked order endpoint](/reference/Trading/Trading_placeOrder). Please note that the `Trade` object returned expires after 5 minutes. Any order placed using an expired `Trade` will be rejected.
     * @summary Check equity order impact
     * @param {TradingApiGetOrderImpactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    getOrderImpact(requestParameters, options) {
        return (0, exports.TradingApiFp)(this.configuration).getOrderImpact(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns quotes from the brokerage for the specified symbols and account. The quotes returned can be delayed depending on the brokerage the account belongs to. It is highly recommended that you use your own market data provider for real-time quotes instead of relying on this endpoint. This endpoint does not work for options quotes.
     * @summary Get equity symbol quotes
     * @param {TradingApiGetUserAccountQuotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    getUserAccountQuotes(requestParameters, options) {
        return (0, exports.TradingApiFp)(this.configuration).getUserAccountQuotes(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Places a bracket order (entry order + OCO of stop loss and take profit). Disabled by default please contact support for use. Only supported on certain brokerages
     * @summary Place bracket equity order
     * @param {TradingApiPlaceBracketOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    placeBracketOrder(requestParameters, options) {
        return (0, exports.TradingApiFp)(this.configuration).placeBracketOrder(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Places an order in the specified account. This endpoint does not compute the impact to the account balance from the order before submitting the order.
     * @summary Place crypto order
     * @param {TradingApiPlaceCryptoOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    placeCryptoOrder(requestParameters, options) {
        return (0, exports.TradingApiFp)(this.configuration).placeCryptoOrder(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Places a brokerage order in the specified account. The order could be rejected by the brokerage if it is invalid or if the account does not have sufficient funds.  This endpoint does not compute the impact to the account balance from the order and any potential commissions before submitting the order to the brokerage. If that is desired, you can use the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact).  It\'s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     * @summary Place order
     * @param {TradingApiPlaceForceOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    placeForceOrder(requestParameters, options) {
        return (0, exports.TradingApiFp)(this.configuration).placeForceOrder(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Places a multi-leg option order. Only supported on certain option trading brokerages. https://snaptrade.notion.site/brokerages has information on brokerage trading support
     * @summary Place option order
     * @param {TradingApiPlaceMlegOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    placeMlegOrder(requestParameters, options) {
        return (0, exports.TradingApiFp)(this.configuration).placeMlegOrder(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Places the previously checked order with the brokerage. The `tradeId` is obtained from the [check order impact endpoint](/reference/Trading/Trading_getOrderImpact). If you prefer to place the order without checking for impact first, you can use the [place order endpoint](/reference/Trading/Trading_placeForceOrder).  It\'s recommended to trigger a manual refresh of the account after placing an order to ensure the account is up to date. You can use the [manual refresh](/reference/Connections/Connections_refreshBrokerageAuthorization) endpoint for this.
     * @summary Place checked equity order
     * @param {TradingApiPlaceOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    placeOrder(requestParameters, options) {
        return (0, exports.TradingApiFp)(this.configuration).placeOrder(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Previews an order using the specified account.
     * @summary Preview crypto order
     * @param {TradingApiPreviewCryptoOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    previewCryptoOrder(requestParameters, options) {
        return (0, exports.TradingApiFp)(this.configuration).previewCryptoOrder(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Replaces an existing pending order with a new one. The way this works is brokerage dependent, but usually involves cancelling the existing order and placing a new one. The order\'s brokerage_order_id may or may not change, be sure to use the one returned in the response going forward. Only supported on some brokerages
     * @summary Replace order
     * @param {TradingApiReplaceOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    replaceOrder(requestParameters, options) {
        return (0, exports.TradingApiFp)(this.configuration).replaceOrder(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Searches cryptocurrency pairs instruments accessible to the specified account.
     * @summary Get crypto pairs
     * @param {TradingApiSearchCryptocurrencyPairInstrumentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApiGenerated
     */
    searchCryptocurrencyPairInstruments(requestParameters, options) {
        return (0, exports.TradingApiFp)(this.configuration).searchCryptocurrencyPairInstruments(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TradingApiGenerated = TradingApiGenerated;
